"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAggregatedIssuesWithVulnPaths = void 0;
const org_1 = require("../../generated/org");
const dep_graph_1 = require("@snyk/dep-graph");
exports.getAggregatedIssuesWithVulnPaths = async (classContext, body) => {
    const projectAggregatedIssues = await new org_1.Org({
        orgId: Object(classContext)['orgId'],
    })
        .project({ projectId: Object(classContext)['projectId'] })
        .aggregatedissues.post(body);
    const projectDepGraph = await new org_1.Org({
        orgId: Object(classContext)['orgId'],
    })
        .project({ projectId: Object(classContext)['projectId'] })
        .depgraph.get();
    const depGraph = dep_graph_1.createFromJSON(projectDepGraph.depGraph);
    let returnData = {
        issues: [],
    };
    // @ts-ignore
    projectAggregatedIssues.issues.map((issue) => {
        // @ts-ignore
        const versionsWithVulnPaths = issue.pkgVersions.map((version) => {
            const pkg = {
                name: issue.pkgName,
                version: version,
            };
            const returnData = {
                [`${pkg.version}`]: getVulnPathsForPkgVersionFromGraph(pkg.name, pkg.version, depGraph),
            };
            return returnData;
        });
        const newIssue = {
            ...issue,
        };
        newIssue.pkgVersions = versionsWithVulnPaths;
        returnData.issues.push(newIssue);
    });
    return returnData;
};
const getVulnPathsForPkgVersionFromGraph = (pkgName, version, depGraph) => {
    const pkg = {
        name: pkgName,
        version: version,
    };
    const pkgVulnPaths = depGraph.pkgPathsToRoot(pkg);
    return pkgVulnPaths.map((vulnPath) => vulnPath
        .map((vulnPathPkg) => `${vulnPathPkg.name}@${vulnPathPkg.version}`)
        .reverse()
        .slice(1));
};
//# sourceMappingURL=aggregatedissues.js.map