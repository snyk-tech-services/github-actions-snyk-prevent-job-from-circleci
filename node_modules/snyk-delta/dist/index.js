#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDelta = void 0;
require("source-map-support/register");
const snyk = require("./snyk/snyk");
const error_1 = require("./error");
const utils = require("./utils/utils");
const issues = require("./snyk/issues");
const dependencies = require("./snyk/dependencies");
const isUUID = require("is-uuid");
const inputError_1 = require("./customErrors/inputError");
const banner = `
================================================                           
================================================
Snyk Tech Prevent Tool
================================================
================================================
`;
const getDelta = async (snykTestOutput = '', debugMode = false) => {
    const argv = utils.init(debugMode);
    const debug = utils.getDebugModule();
    const mode = argv.currentProject || argv.currentOrg ? "standalone" : "inline";
    try {
        if (process.env.NODE_ENV == 'prod') {
            console.log(banner);
        }
        debug(mode, "mode");
        let snykTestJsonDependencies, snykTestJsonResults;
        let baselineOrg = argv.baselineOrg ? argv.baselineOrg : "";
        let baselineProject = argv.baselineProject ? argv.baselineProject : "";
        const currentOrg = argv.currentOrg ? argv.currentOrg : "";
        const currentProject = argv.currentProject ? argv.currentProject : "";
        if (mode == "inline") {
            const pipedData = snykTestOutput == '' ? await utils.getPipedDataIn() : "" + snykTestOutput;
            // Verify it's JSON data structure
            debug("Verify input data for JSON structure");
            const inputData = JSON.parse("[" + pipedData.replace(/}\n{/g, "},\n{").replace("}\n[", "},\n[") + "]");
            // TODO: Handle --all-projects setups, bail for now
            if (inputData.length > 2) {
                console.log("Sorry, I can't handle --all-projects commands right now, but soon !");
                process.exitCode = 2;
            }
            snykTestJsonDependencies = inputData.length > 1 ? inputData[0] : null;
            snykTestJsonResults = inputData.length > 1 ? inputData[1] : inputData[0];
            const projectNameFromJson = snykTestJsonResults.targetFile ?
                `${snykTestJsonResults.projectName}:${snykTestJsonResults.targetFile}` :
                `${snykTestJsonResults.projectName}`;
            baselineOrg = baselineOrg ? baselineOrg : snykTestJsonResults.org;
            baselineProject = baselineProject ? baselineProject : projectNameFromJson;
            if (argv.baselineProject && !isUUID.anyNonNil(baselineProject)) {
                throw new inputError_1.BadInputError("Project ID must be valid UUID");
            }
            if (!isUUID.anyNonNil(baselineProject)) {
                baselineProject = await snyk.getProjectUUID(baselineOrg, baselineProject);
            }
        }
        else {
            // Pull data from currentOrg/currentProject for issues and dep graph and drop it into input data.
            if (!argv.currentProject || !argv.currentOrg || !argv.baselineOrg || !argv.baselineProject) {
                throw new inputError_1.BadInputError("You must provide org AND project IDs for baseline project and current project");
            }
            // if(!isUUID.anyNonNil(baselineProject) || (currentProject && !isUUID.anyNonNil(currentProject))){
            //   throw new BadInputError("Project IDs must be UUID")
            // }
            debug(`Retrieve Snyk Project to compare %s in org %s`, currentOrg, currentProject);
            snykTestJsonDependencies = await snyk.getProjectDepGraph(currentOrg, currentProject);
            const projectIssuesFromAPI = await snyk.getProjectIssues(currentOrg, currentProject);
            snykTestJsonResults = projectIssuesFromAPI.issues;
        }
        debug(`Retrieve Snyk Project %s in org %s`, baselineProject, baselineOrg);
        const issueTypeFilter = argv.type ? argv.type : "all";
        const snykProject = await snyk.getProjectIssues(baselineOrg, baselineProject);
        const newVulns = issues.getNewVulns(snykProject, snykTestJsonResults, mode);
        const newLicenseIssues = issues.getNewLicenseIssues(snykProject, snykTestJsonResults, mode);
        debug(`New Vulns count =%d`, newVulns.length);
        debug(`New Licenses Issues count =%d`, newLicenseIssues.length);
        if (snykTestJsonDependencies) {
            const monitoredProjectDepGraph = await snyk.getProjectDepGraph(baselineOrg, baselineProject);
            await dependencies.displayDependenciesChangeDetails(snykTestJsonDependencies, monitoredProjectDepGraph, snykTestJsonResults.packageManager, newVulns, newLicenseIssues);
        }
        if ((newVulns.length > 0 && issueTypeFilter != "license") || (newLicenseIssues.length > 0 && issueTypeFilter != "vuln")) {
            utils.displaySplash();
            if (newVulns.length > 0 && issueTypeFilter != "license") {
                issues.displayNewVulns(newVulns, mode);
            }
            if (newLicenseIssues.length > 0 && issueTypeFilter != "vuln") {
                issues.displayNewLicenseIssues(newLicenseIssues, mode);
            }
            process.exitCode = 1;
        }
        else {
            console.log("No new issues found !");
            process.exitCode = 0;
        }
    }
    catch (err) {
        error_1.default(err);
        process.exitCode = 2;
    }
    finally {
        if (!module.parent) {
            process.exit(process.exitCode);
        }
        else {
            return process.exitCode;
        }
    }
};
exports.getDelta = getDelta;
if (!module.parent) {
    getDelta();
}
//# sourceMappingURL=index.js.map